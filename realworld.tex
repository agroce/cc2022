\section{Non-Experimental Fuzzing Campaigns:  Bugs Reported}
\label{real-world}

{\bf WE NEED A NICE TABLE OF BUG CATEGORIES FOR ALL THE CAMPAIGNS WE RAN, INCLUDING CAMPAIGN LENGTH}


\begin{table}
\centering
\begin{tabular}{lrr|rrr}
\toprule
                    \bf Project       & \bf Length & \bf Total                        & \cmark            & \clock                  & \acirc                 \\
\midrule
                    Solidity          & ????       & \solUniqueFixedOrConfirmed      & \solUniqueFixed   & \solUniqueConfirmed     & \solAValidDuplicates   \\
                                      % Fuzz: about a week Reports: Jan 27 to Feb 9 2021.
                    Move              & 20d        & \movUniqueFixedOrConfirmed       & \movUniqueFixed   & \movUniqueConfirmed     & 0                      \\
                                                                                                                                    % 63 submittd, 49 are fixed or confirmed, are the other 14 wrong or dups?
                    Fe                & ????       & \feUniqueFixedOrConfirmed        & \feUniqueFixed    & \feUniqueConfirmed      & {\color{red}(14?)}      \\
                                      % Fuzz: about a week. Reports: 1 day
                    Zig               & 7d         & \zigUniqueFixedOrConfirmed       & 0                 & \zigUniqueConfirmed     & 0                      \\
\midrule
                    All               & ???        & \allUniqueFixedOrConfirmed       & \allUniqueFixed   & \allUniqueConfirmed     & \solAValidDuplicates    \\
\bottomrule
\end{tabular}
\caption{Fuzzing campaign results for real world bugs.
Table shows all reported bugs to project's upstream issue
tracker and status.  \cmark~is \textbf{fixed} bugs. \clock~is \textbf{confirmed but unfixed bugs}. 
\acirc~is \textbf{duplicate bug reports} (either reported
duplicatively by us or another contributor).
% \xmark~is \textbf{invalid} bug reports (deemed not a real bug, i.e., WONTFIX). 
\textbf{Total} is the number of true, unique bugs reported and acknowledged by maintainers (\cmark~Fixed + \clock~Unfixed bugs).
{\color{red} Table to include Alex's bugs still.} 
{\color{red} Alex to answer: what do want to put for "campaign length" here? Fuzz time, or time span of bug reports? Or both (and we add a column)?}
}
\label{tab:campaign-fixes}
\end{table}

\begin{table*}
\centering
\begin{tabular}{lcll}
\toprule
                    \bf Project       & \bf Bug kind                  & \bf Ref                                                                                                         & \bf Time to fix   \\ 
\midrule                               
                    \mr{2}{Solidity}  &                               &                                                                                                                 &                   \\
                                      &                               &                                                                                                                 &                   \\
\cmidrule{2-4}                               
                    \mr{3}{Move}      & incorrect struct type arity   & \href{https://github.com/diem/diem/pull/7401}{\#7401}                                                           & 1d                \\
                                      & broken ref type constraint    & \href{https://github.com/diem/diem/pull/7613/commits/9af7ababb42c2d580869c4e697aa2321bc27bb98}{\#7613}          & 1d                \\
                                      & ...                           &                                                                                                                 &                   \\
\cmidrule{2-4}                               
                    \mr{2}{Fe}        &                               &                                                                                                                 &                   \\
                                      &                               &                                                                                                                 &                   \\
\bottomrule
\end{tabular}
\caption{Detailed bug exemplars. \textbf{Time to fix} is the time taken from report to fix being merged.}
\label{tab:bug-breakdown}
\end{table*}




Perhaps the most important evidence of the effectiveness of this approach is that we applied it to fuzzing the Solidity compiler for over a year, and in that time reported XX bugs that have been fixed.  Prior to and during our campaign, Solidity had been fuzzed heavily using AFL, by the developers and by external contributors.  Despite competing with the internal fuzzing team of the project and other developers, and never devoting more resources to the fuzzing than 3-4 docker container hosted instances of our fuzzing tool, running on a high-end laptop, we believe that our campaign was the largest single source of fuzzing-discovered bugs in the compiler during our campaign.  The campaign was awarded a security bounty of \$1,000 USD in Ethereum for discovery of a bug with potential security implications (and, it was noted, for the general effectiveness of the fuzzing), and the Solidity team encouraged and aided our efforts, once it was clear that the approach was very useful in exposing subtle bugs.

A second long-term fuzzing effort was directed at the Fe language, a Rust/Python-like alternative to Solidity for writing Ethereum contracts.  Fe is an experimental language, and the project has far fewer resources than Solidity to devote to testing.  We worked with the Fe developers to make Fe crash in additional cases, and were able to provide them with high-quality fuzzing very early in the lifetime of an experimental compiler project.  We believe this effort was very useful to the Fe team, based on their comments, and speculate that better ``no-fuss'' fuzzing could expose language corner cases early in the implementation of a compiler, avoiding costly changes when more code depends on erroneous assumptions, or poor language design choices.

At the time we fuzzed Facebook's \texttt{Move} compiler, the project had been fuzzing various components, but less so the smart language compiler itself.
The majority of bugs reported in \texttt{Move} compiler were quickly confirmed and fixed, and developers expressed interest in incorporating our approach into their fuzzing CI.\footnote{Link to public dialog omitted for anonymity.}  % link: https://github.com/diem/diem/issues/7384#issuecomment-769443728


We ran a shorter, less-intensive campaign on the \texttt{Zig} compiler.  The
\texttt{Zig} compiler continues to be under heavy development, and a small team
of maintainers are prioritizing effort to rewrite the components where we found
bugs.
