\section{Mutation-Testing-Based Compiler Fuzzing}



\subsection{Mutation-Based Fuzzing}

One use of the term ``mutation'' appears in the context of \emph{mutation-based} fuzzing~\cite{ArtFuzz}.  One can consider two basic kinds of compiler testing based on the generation of random input programs.  One, in recent years paradigmatically expressed in the Csmith tool~\cite{csmith}, works by using a grammar and deep knowledge of the language accepted by the compiler, to generate programs to test the compiler.  This is sometimes called \emph{generative} fuzzing.  A second approach is to use an off-the-shelf fuzzer, such is used to find security vulnerabilities (e.g., the ubiquitous American Fuzzy Lop (AFL) \url{https://github.com/google/AFL}), and a \emph{corpus} of example programs, such as the set of regression tests for the compiler or a set of real-world programs.  A fuzzer such as AFL operates by executing the program under test (here, the compiler) on inputs (initially those in the corpus), using instrumentation to determine code coverage in the compiler for each executed input.  The fuzzer then takes inputs that look interesting and adds them to a \emph{queue}.  The basic loop is then to take some input from the queue, \emph{mutate} it by making some essentially random change (e.g., flipping a single bit, or removing a random chunk of bytes), execute the new, mutated input under instrumentation, and add the new input to the queue if it seems ``interesting'' --- typically, if it hits some kind of coverage target that has not previously been hit.  The details of selecting inputs from the queue and determining how to mutate an input vary widely, and improving the effectiveness of this basic approach has been a major topic of recent software testing and security research.  However, the basic strategy usually still fits into a simple basic model:

\begin{enumerate}
\item Select an input from the queue.
\item Mutate that input in order to obtain a new input.
\item Execute the new input, and if it is deemed interesting, add it to the queue.
\item Go back to the first step.
\end{enumerate}

Any inputs that crash the compiler in step 3 are reported to the user.  Using such a fuzzer is often extremely easy, involving no more work than 1) building the compiler with special instrumentation and 2) finding a set of initial programs to use as a corpus.  Even compiling with instrumentation can be optional; some fuzzers (including AFL) can use QEMU to fuzz arbitrary binaries.  However, for compilers, it is usually best if possible to rebuild the compiler, since QEMU-based execution is much slower, and compilers are slow enough to seriously degrade fuzzing throughput.

\subsection{Mutation Testing}

A different use of the term ``mutation'' appears in the field of mutation testing.  Mutation testing~\cite{MutationSurvey,budd1979mutation,demillo1978hints} is an approach to evaluating and improving software tests that works by introducing small syntactic changes into a program, under the assumption that if the original program was correct, then a program with slightly different semantics will be incorrect, and should be flagged as such by effective tests.  Mutation testing is now widely used in software testing research, and is used to varying degrees in industry at-scale and for especially critical software development~\cite{mutKernel,mutGoogle,mutFacebook}.

\subsection{Limitations}

The most important limitation for the mutation-testing-based approach is that if compiler \emph{crashes} are mostly uninteresting, fuzzing of this kind will probably not be very useful.  This applies, of course, to all AFL-style fuzzing, not just to fuzzing using the technique proposed in this paper.  For example, C and C++ include a large variety of undefined behaviors.  Code that crashes a C or C++ compiler, but that includes (unusual) undefined behavior may well be ignored by developers.  Csmith~\cite{csmith} devotes a great deal of effort to avoiding generating code that falls outside the ``interesting'' part of the language.  On the other hand, many languages more recent than C and C++ attempt to provide a more ``total'' language where, while a program may be considered absurd by a human, fewer (or no) programs are undefined in the sense that C and C++ use the term.  For example, smart contract languages such as those studied in this paper, generally aim to make all programs that compile well-defined, or at least minimize the problem to more manageable cases such as order of evaluation of sub-expressions.  Similarly, Rust code without use of {\tt unsafe} or libraries using {\tt unsafe} should be well-defined.  For most more recent languages, and some older languages such as Java, a program that crashes the compiler is, in general, likely of interest to compiler developers.  However, the proposed technique will be much more limited in effectiveness for C and C++ compilers.