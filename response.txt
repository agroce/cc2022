#5A:

We focused on these languages because they all avoided undefined behavior and we knew would view any bugs as serious, so confirm/deny quickly (and unlike gcc/llvm are not overwhelmed with a bug backlog).  The programs in compiler tests (our source of a corpus) tend to be relatively small, since developers find such easier to debug/maintain.  For longer programs, mutation might not be as useful.

> blindly swapping

Yes, though non-compiling code can also reveal bugs.  The code is, except for type names, valid Solidity as well, just meant as "generic code."

> invalid mutants

Varies by program, seeds, and fuzzing stage (but fewer with Comby).  Note that an invalid mutant can reveal a compiler bug.

> ratios

Agreed.   We'll discuss our (non-exhaustive) trials a bit more; the numbers are configurable, and it's possible our rough estimates are non-optimal for many compilers.

> syntactically well-formed program without a known grammar

The key is that _given a well-formed corpus program_ mutation operators _tend to_ produce well formed mutated programs.  There is no guarantee, but there is likelyhood due to the nature of operators.

Q1:  We have not seriously fuzzed LLVM or GCC.  We did run a small experiment on TinyCC and found significantly more crash bugs than AFL.  However, as the paper notes, the approach is most relevant where something like Csmith is not available and undefined behavior (UB) is not importany.  Perhaps we should run on clang++, etc., but UB would still be a problem.

Q2:  Not sure we understand this question?  We have used OSS-Fuzz in other contexts, and solc is on OSS-Fuzz, but as we understand it, OSS-Fuzz only supports their versions of AFL/libFuzzer, etc.

Q3:  For Solidity, the project where we have best data (it has been fuzzed substantially with AFL in public) the answer seems to be about 40-50 at most (mostly from OSS-Fuzz) compared to our 70+.

Q4:  We have not performed longer _controlled_ experiments.  Many of the bugs we reported are from longer runs, and informal similarly-long plain-AFL runs for comparison did not hit those bugs.

#5B:

We will discuss DeepSmith, etc..  Comparing against CSmith is out of scope for rebuttal, but would be interesting.  The fact that we would produce programs with undefined behavior in C very frequently, and CSmith would not, would make it harder to interpret any numbers.

#5C:

As far as we know, nobody has seriously applied symex to these targets, and we are dubious of the scalability.

The Solidity bounty was for a bug that found a case where invalid assembly was eventually generated due to improper escaping of backslashes, which could lead to code that appeared to do one thing, but in fact did something else via clever construction.  The example found revealed a larger issue, and paranoid comparison of scanner results was considered as a response.  Both "our" mutation to shape a context program and AFL-mutation to produce a dangerous string were needed.

Solidity is a complex optimizing compiler implemented in close to 300KLOC of complex C++ code.  Fe is an experimental, in-progress compiler with a simpler optimizer (and use of the Solc Yul backend for further optimization) implemented in about 22KLOC of Rust.

RIJNARD:  Can you comment on the complexity of the other compilers? 

The Solidity bugs were sometimes in the parser/scanner, but mostly in various optimization/code-gen stages.  For Fe, about half of bugs were in parsing/scanning, and half in deeper optimization stages.

RIJNARD:  Can you talk about where the other bugs were?

The decomposition approach is, to our knowledge, novel.

The Comby tool's performance is show in comparisons, but the Python Universal Mutator was not used because the slowdown was well over 1000x (calling out to Python and using Python regexp processing etc.), to the point of being impractical.

