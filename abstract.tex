Developing a bug-free compiler is difficult; modern optimizing compilers are among the most complex software systems humans build.  Fuzzing is one way to identify subtle compiler bugs that are hard to find with human-constructed tests.  Grammar-based fuzzing, however, requires a grammar for a compiler's input language, and can miss bugs induced by code that does not actually satisfy the grammar the compiler \emph{should} acccept.  Grammar-based fuzzing also seldom uses advanced modern fuzzing techniques based on coverage feedback.  However, modern mutation-based fuzzers are often ineffective for testing compilers because most inputs they generate do not even come close to getting past the parsing stage of compilation.   This paper introduces a technique for taking a modern mutation-based fuzzer (AFL in our case, but the method is general) and adding mutation rules, based on operators used in mutation testing, to make such fuzzing more effective.  We show that adding such mutations significantly improves fuzzing effectiveness.  Our approach has allowed us to report more than 100 confirmed and fixed bugs in production compilers, and found a bug in the Solidity compiler that earned a security bounty.  The most important feature of our approach is that for compilers written in C, C++, Go, Rust, or another language supported by AFL, the process of fuzzing is extremely low-effort for compiler developers.  They essentially build their system with fuzzer instrumentation, point the fuzzer to a set of example programs that compile without error, and examine any crashes detected.
