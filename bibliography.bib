@misc{buterin2013whitepaper,
  author = {Vitalik Buterin},
  title = {Ethereum: A Next-Generation Smart Contract and Decentralized Application Platform},
  howpublished = "\url{https://github.com/ethereum/wiki/wiki/White-Paper}",
  year = {2013}
}

@misc{vsbenchmark,
title = "{VeriSmart} benchmark",
  howpublished={\url{https://github.com/kupl/VeriSmart-benchmarks}}
  }

@inproceedings{flaky,
author = {Eck, Moritz and Palomba, Fabio and Castelluccio, Marco and Bacchelli, Alberto},
title = {Understanding Flaky Tests: The Developer’s Perspective},
year = {2019},
isbn = {9781450355728},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3338906.3338945},
doi = {10.1145/3338906.3338945},
abstract = {Flaky tests are software tests that exhibit a seemingly random outcome (pass or fail)
despite exercising unchanged code. In this work, we examine the perceptions of software
developers about the nature, relevance, and challenges of flaky tests. We asked 21
professional developers to classify 200 flaky tests they previously fixed, in terms
of the nature and the origin of the flakiness, as well as of the fixing effort. We
also examined developers' fixing strategies. Subsequently, we conducted an online
survey with 121 developers with a median industrial programming experience of five
years. Our research shows that: The flakiness is due to several different causes,
four of which have never been reported before, despite being the most costly to fix;
flakiness is perceived as significant by the vast majority of developers, regardless
of their team's size and project's domain, and it can have effects on resource allocation,
scheduling, and the perceived reliability of the test suite; and the challenges developers
report to face regard mostly the reproduction of the flaky behavior and the identification
of the cause for the flakiness. Public preprint [http://arxiv.org/abs/1907.01466],
data and materials [https://doi.org/10.5281/zenodo.3265785].},
booktitle = {Proceedings of the 2019 27th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
pages = {830–840},
numpages = {11},
keywords = {Mixed-Method Research, Flaky Tests, Empirical Studies},
location = {Tallinn, Estonia},
series = {ESEC/FSE 2019}
}

@article{boehmeCR21,
  author    = {Marcel B{\"{o}}hme and
               Cristian Cadar and
               Abhik Roychoudhury},
  title     = {Fuzzing: Challenges and Reflections},
  journal   = {{IEEE} Softw.},
  volume    = {38},
  number    = {3},
  pages     = {79--86},
  year      = {2021},
}



@inproceedings{fuzzexp,
author = {B\"{o}hme, Marcel and Falk, Brandon},
title = {Fuzzing: On the Exponential Cost of Vulnerability Discovery},
year = {2020},
isbn = {9781450370431},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3368089.3409729},
doi = {10.1145/3368089.3409729},
abstract = {We present counterintuitive results for the scalability of fuzzing. Given the same
non-deterministic fuzzer, finding the same bugs linearly faster requires linearly
more machines. For instance, with twice the machines, we can find all known bugs in
half the time. Yet, finding linearly more bugs in the same time requires exponentially
more machines. For instance, for every new bug we want to find in 24 hours, we might
need twice more machines. Similarly for coverage. With exponentially more machines,
we can cover the same code exponentially faster, but uncovered code only linearly
faster. In other words, re-discovering the same vulnerabilities is cheap but finding
new vulnerabilities is expensive. This holds even under the simplifying assumption
of no parallelization overhead. We derive these observations from over four CPU years
worth of fuzzing campaigns involving almost three hundred open source programs, two
state-of-the-art greybox fuzzers, four measures of code coverage, and two measures
of vulnerability discovery. We provide a probabilistic analysis and conduct simulation
experiments to explain this phenomenon.},
booktitle = {Proceedings of the 28th ACM Joint Meeting on European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
pages = {713–724},
numpages = {12},
keywords = {scalability, software testing, efficiency, fuzzing},
location = {Virtual Event, USA},
series = {ESEC/FSE 2020}
}



@inproceedings{echidnaissta,
author = {Grieco, Gustavo and Song, Will and Cygan, Artur and Feist, Josselin and Groce, Alex},
title = {Echidna: Effective, Usable, and Fast Fuzzing for Smart Contracts},
year = {2020},
address = {New York, NY, USA},
booktitle = {ACM SIGSOFT International Symposium on Software Testing and Analysis},
pages = {557–560}
}



@inproceedings{verismart,
    title={{VeriSmart}: A Highly Precise Safety Verifier for Ethereum Smart Contracts},
    author={Sunbeom So and Myungho Lee and Jisu Park and Heejo Lee and Hakjoo Oh},
    year={2020},
   booktitle={{IEEE} Symposium on Security \& Privacy},
   notes = {accepted for publication}
}

@misc{measurepop,
  howpublished="\url{https://github.com/smartanvil/smartanvil.github.io/blob/master/_posts/2018-03-14-on-contract-popularity-analysis.md}",
  title="On Contract Popularity Analysis",
  author="Santiago Bragagnolo"
}

@techreport{smartanvil,
  title={SmartAnvil: Open-Source Tool Suite for Smart Contract Analysis},
  author={Ducasse, St{\'e}phane and Rocha, Henrique and Bragagnolo, Santiago and Denker, Marcus and Francomme, Cl{\'e}ment},
  year={2019},
  institution="{HAL}",
  number="hal-01940287"
}

@mastersthesis{dika2017ethereum,
  title={Ethereum Smart Contracts: Security Vulnerabilities and Security Tools},
  author={Dika, Ardit},
  year={2017},
  school={NTNU}
}

@inproceedings{chen2018under,
 author = {Chen, Ting and Li, Zihao and Zhou, Hao and Chen, Jiachi and Luo, Xiapu and Li, Xiaoqi and Zhang, Xiaosong},
 title = {Towards Saving Money in Using Smart Contracts},
 booktitle = {Proceedings of the 40th International Conference on Software Engineering: New Ideas and Emerging Results},
 series = {ICSE-NIER '18},
 year = {2018},
 isbn = {978-1-4503-5662-6},
 location = {Gothenburg, Sweden},
 pages = {81--84},
 numpages = {4},
 url = {http://doi.acm.org/10.1145/3183399.3183420},
 doi = {10.1145/3183399.3183420},
 acmid = {3183420},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {anti-patterns, detection, optimization, smart contract},
} 

@inproceedings{chen2017under,
  title={Under-optimized smart contracts devour your money},
  author={Chen, Ting and Li, Xiaoqi and Luo, Xiapu and Zhang, Xiaosong},
  booktitle={Software Analysis, Evolution and Reengineering (SANER), 2017 IEEE 24th International Conference on},
  pages={442--446},
  year={2017},
  organization={IEEE}
}

@misc{wood2014yellow,
  author = {Gavin Wood},
  title = {Ethereum:  a  secure  decentralised  generalised  transaction  ledger},
  howpublished = "\url{http://gavwood.com/paper.pdf}",
  year = {2014}
}

@misc{nakamoto2008bitcoin,
  title={Bitcoin: A peer-to-peer electronic cash system},
  author={Satoshi Nakamoto},
  howpublished = "\url{https://bitcoin.org/bitcoin.pdf}",
  year={2008}
}

@inproceedings{slitherpaper,
  author = "Josselin Feist and Gustavo Greico and Alex Groce",
  title = "Slither: A Static Analysis Framework For Smart Contracts",
  year = 2019,
  booktitle = "International Workshop on Emerging Trends in Software Engineering for Blockchain",
  }

@misc{parity,
  title={Parity Ethereum client},
  author={Parity},
  howpublished = "\url{https://parity.io}",
  year={2016}
}

@misc{special,
  title={Journal Special Issue on Fuzzing:
What about Preregistration?},
  author={Marcel B\"{o}hme and L\'{a}szl\'{o} Szekeres and Baishakhi Ray and Cristian Cadar},
  howpublished={\url{http://fuzzbench.com/blog/2021/04/22/special-issue/}},
  year={2021},
  month={April}}


@inproceedings{evalfuzz,
author = {Klees, George and Ruef, Andrew and Cooper, Benji and Wei, Shiyi and Hicks, Michael},
title = {Evaluating Fuzz Testing},
year = {2018},
isbn = {9781450356930},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3243734.3243804},
doi = {10.1145/3243734.3243804},
abstract = {Fuzz testing has enjoyed great success at discovering security critical bugs in real
software. Recently, researchers have devoted significant effort to devising new fuzzing
techniques, strategies, and algorithms. Such new ideas are primarily evaluated experimentally
so an important question is: What experimental setup is needed to produce trustworthy
results? We surveyed the recent research literature and assessed the experimental
evaluations carried out by 32 fuzzing papers. We found problems in every evaluation
we considered. We then performed our own extensive experimental evaluation using an
existing fuzzer. Our results showed that the general problems we found in existing
experimental evaluations can indeed translate to actual wrong or misleading assessments.
We conclude with some guidelines that we hope will help improve experimental evaluations
of fuzz testing algorithms, making reported results more robust.},
booktitle = {Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communications Security},
pages = {2123–2138},
numpages = {16},
keywords = {security, evaluation, fuzzing},
location = {Toronto, Canada},
series = {CCS '18}
}

@article{MutReduct,
  author    = {Rahul Gopinath and
               Iftekhar Ahmed and
               Mohammad Amin Alipour and
               Carlos Jensen and
               Alex Groce},
  title     = {Mutation Reduction Strategies Considered Harmful},
  journal   = {{IEEE} Trans. Reliab.},
  volume    = {66},
  number    = {3},
  pages     = {854--874},
  year      = {2017},
  url       = {https://doi.org/10.1109/TR.2017.2705662},
  doi       = {10.1109/TR.2017.2705662},
  timestamp = {Thu, 14 Oct 2021 09:06:33 +0200},
  biburl    = {https://dblp.org/rec/journals/tr/GopinathAAJG17.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{testedness,
author = {Ahmed, Iftekhar and Gopinath, Rahul and Brindescu, Caius and Groce, Alex and Jensen, Carlos},
title = {Can Testedness Be Effectively Measured?},
year = {2016},
isbn = {9781450342186},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2950290.2950324},
doi = {10.1145/2950290.2950324},
abstract = { Among the major questions that a practicing tester faces are deciding where to focus
additional testing effort, and deciding when to stop testing. Test the least-tested
code, and stop when all code is well-tested, is a reasonable answer. Many measures
of "testedness" have been proposed; unfortunately, we do not know whether these are
truly effective. In this paper we propose a novel evaluation of two of the most important
and widely-used measures of test suite quality. The first measure is statement coverage,
the simplest and best-known code coverage measure. The second measure is mutation
score, a supposedly more powerful, though expensive, measure. We evaluate these measures
using the actual criteria of interest: if a program element is (by these measures)
well tested at a given point in time, it should require fewer future bug-fixes than
a "poorly tested" element. If not, then it seems likely that we are not effectively
measuring testedness. Using a large number of open source Java programs from Github
and Apache, we show that both statement coverage and mutation score have only a weak
negative correlation with bug-fixes. Despite the lack of strong correlation, there
are statistically and practically significant differences between program elements
for various binary criteria. Program elements (other than classes) covered by any
test case see about half as many bug-fixes as those not covered, and a similar line
can be drawn for mutation score thresholds. Our results have important implications
for both software engineering practice and research evaluation. },
booktitle = {Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
pages = {547–558},
numpages = {12},
keywords = {coverage criteria, statistical analysis, mutation testing, test suite evaluation},
location = {Seattle, WA, USA},
series = {FSE 2016}
}



@article{HolmesLOC,
author = {Holmes, Josie and Ahmed, Iftekhar and Brindescu, Caius and Gopinath, Rahul and Zhang, He and Groce, Alex},
title = {Using Relative Lines of Code to Guide Automated Test Generation for Python},
year = {2020},
issue_date = {October 2020},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {29},
number = {4},
issn = {1049-331X},
url = {https://doi.org/10.1145/3408896},
doi = {10.1145/3408896},
abstract = {Raw lines of code (LOC) is a metric that does not, at first glance, seem extremely useful for automated test generation. It is both highly language-dependent and not extremely meaningful, semantically, within a language: one coder can produce the same effect with many fewer lines than another. However, relative LOC, between components of the same project, turns out to be a highly useful metric for automated testing. In this article, we make use of a heuristic based on LOC counts for tested functions to dramatically improve the effectiveness of automated test generation. This approach is particularly valuable in languages where collecting code coverage data to guide testing has a very high overhead. We apply the heuristic to property-based Python testing using the TSTL (Template Scripting Testing Language) tool. In our experiments, the simple LOC heuristic can improve branch and statement coverage by large margins (often more than 20%, up to 40% or more) and improve fault detection by an even larger margin (usually more than 75% and up to 400% or more). The LOC heuristic is also easy to combine with other approaches and is comparable to, and possibly more effective than, two well-established approaches for guiding random testing.},
journal = {ACM Trans. Softw. Eng. Methodol.},
month = sep,
articleno = {28},
numpages = {38},
keywords = {Automated test generation, static code metrics, testing heuristics}
}

@misc{slither-code,
  title={Slither: a static analyzer for Solidity},
  author={{Anonymized for review}},
  howpublished = "{Anonymized for review}",
  year={2018}
}


%  title={Slither: a static analyzer for Solidity},
%  author={{Trail of Bits}},
%  howpublished = "\url{https://github.com/trailofbits/slither}",
%  year={2018}
%}



@misc{slither-api,
  title={{Slither Python API}},
  author={{Trail of Bits}},
  howpublished = "\url{https://github.com/trailofbits/slither/wiki/API-examples}",
  year={2018}
}


@misc{slither-slithir,
  title={SlithIR Documentation},
  author={{Trail of Bits}},
  howpublished = "\url{https://github.com/trailofbits/slither/wiki/SlithIR}",
  year={2018}
}




@misc{spank,
  title={We Got Spanked: What We Know So Far},
  author={{SpankChain}},
  howpublished = "\url{https://medium.com/spankchain/we-got-spanked-what-we-know-so-far-d5ed3a0f38fe}",
  year={Oct 8, 2018 (acceded on Jan 10, 2019)}
}

@inproceedings{SurveyAttacks,
 author = {Atzei, Nicola and Bartoletti, Massimo and Cimoli, Tiziana},
 title = {A Survey of Attacks on {Ethereum} Smart Contracts {SoK}},
 booktitle = {International Conference on Principles of Security and Trust},
 year = {2017},
 pages = {164--186},
 url = {https://doi.org/10.1007/978-3-662-54455-6_8},
 doi = {10.1007/978-3-662-54455-6_8}
} 

@misc{reports,
  title={Trail of Bits Security Reviews},
  author = {{Trail of Bits}},
  howpublished="\url{https://github.com/trailofbits/publications\#security-reviews}",
  year=2019
  }

@misc{DAO,
  title={Analysis of the DAO exploit},
  author={{Phil Daian }},
  howpublished = "\url{http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/}",
  year={June 18, 2016 (acceded on Jan 10, 2019)}
}

@misc{echidna-code,
  title={Echidna: Ethereum fuzz testing framework},
  author={{Trail of Bits}},
  howpublished = "\url{https://github.com/trailofbits/echidna}",
  year={2018}
}

@misc{mythril-code,
  title={Mythril: a security analysis tool for Ethereum smart contracts},
  author={ConsenSys},
  howpublished = "\url{https://github.com/ConsenSys/mythril-classic}",
  year={2017}
}

@misc{manticore-code,
  title={Manticore: Symbolic Execution for Humans},
  author={{Trail of Bits}},
  howpublished="\url{https://github.com/trailofbits/manticore}",
  year={2017}
}

@misc{mythx,
  howpublished="\url{https://mythx.io/}",
  author="Consensys Diligence",
  }

@misc{solhint-code,
  title={Solhint: an open source project for linting solidity code},
  author={Protofire},
  howpublished = "\url{https://protofire.github.io/solhint/}",
  year={2017}
}

@misc{oyente-code,
  title={Oyente: an analysis tool for smart contracts},
  author={Melon Project},
  howpublished = "\url{https://github.com/melonproject/oyente}",
  year={2017}
}


@misc{etherscan,
  title={Verified contracts synced from Etherscan},
  author={Gerhard Wagner},
  howpublished = "\url{https://github.com/thec00n/etherscan_verified_contracts}",
  year={2018}
}

@misc{aflfuzz,
  title = "american fuzzy lop (2.35b)",
  author = "Michal Zalewski",
  howpublished = "\url{http://lcamtuf.coredump.cx/afl/}",
  note = "Accessed December 20, 2016"
}

@inproceedings{ClaessenH00,
author    = {Koen Claessen and
           John Hughes},
title     = {{QuickCheck}: a lightweight tool for random testing of {Haskell}
           programs},
booktitle = {International Conference on Functional Programming {(ICFP)}},
year      = {2000},
pages     = {268--279},
ee        = {http://doi.acm.org/10.1145/351240.351266},
bibsource = {DBLP, http://dblp.uni-trier.de}
}

@inproceedings{Salls2021TokenLevel,
  title     = {{Token-Level Fuzzing}},
  author    = {Salls, Christopher and Jindal, Chani and Corina, Jake and Kruegel, Christopher and Vigna, Giovanni},
  booktitle = {30th USENIX Security Symposium (USENIX Security 21)},
  year      = {2021}
}

@article{chen2020survey,
  title={A survey of compiler testing},
  author={Chen, Junjie and Patra, Jibesh and Pradel, Michael and Xiong, Yingfei and Zhang, Hongyu and Hao, Dan and Zhang, Lu},
  journal={ACM Computing Surveys (CSUR)},
  volume={53},
  number={1},
  pages={1--36},
  year={2020},
  publisher={ACM New York, NY, USA}
}

@inproceedings{regexpMut,
 author = {Groce, Alex and Holmes, Josie and Marinov, Darko and Shi, August and Zhang, Lingming},
 title = {An Extensible, Regular-expression-based Tool for Multi-language Mutant Generation},
 booktitle = {Proceedings of the 40th International Conference on Software Engineering: Companion Proceeedings},
 series = {ICSE '18},
 year = {2018},
 isbn = {978-1-4503-5663-3},
 location = {Gothenburg, Sweden},
 pages = {25--28},
 numpages = {4},
 url = {http://doi.acm.org/10.1145/3183440.3183485},
 doi = {10.1145/3183440.3183485},
 acmid = {3183485},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {multi-language tools, mutation testing, regular expressions},
}

@ARTICLE {ArtFuzz,
author = {V. Manes and H. Han and C. Han and s. cha and M. Egele and E. J. Schwartz and M. Woo},
journal = {IEEE Transactions on Software Engineering},
title = {The Art, Science, and Engineering of Fuzzing: A Survey},
year = {5555},
volume = {},
number = {01},
issn = {1939-3520},
pages = {1-1},
keywords = {fuzzing;security;computer bugs;terminology},
doi = {10.1109/TSE.2019.2946563},
publisher = {IEEE Computer Society},
address = {Los Alamitos, CA, USA},
month = {oct}
}

@INPROCEEDINGS{MutFacebook,
  author={Beller, Moritz and Wong, Chu-Pan and Bader, Johannes and Scott, Andrew and Machalica, Mateusz and Chandra, Satish and Meijer, Erik},
  booktitle={2021 IEEE/ACM 43rd International Conference on Software Engineering: Software Engineering in Practice (ICSE-SEIP)}, 
  title={What It Would Take to Use Mutation Testing in Industry—A Study at Facebook}, 
  year={2021},
  volume={},
  number={},
  pages={268-277},
  doi={10.1109/ICSE-SEIP52600.2021.00036}}

@inproceedings{MutGoogle,
author = {Petrovi\'{c}, Goran and Ivankovi\'{c}, Marko},
title = {State of Mutation Testing at Google},
year = {2018},
isbn = {9781450356596},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3183519.3183521},
doi = {10.1145/3183519.3183521},
abstract = {Mutation testing assesses test suite efficacy by inserting small faults into programs
and measuring the ability of the test suite to detect them. It is widely considered
the strongest test criterion in terms of finding the most faults and it subsumes a
number of other coverage criteria. Traditional mutation analysis is computationally
prohibitive which hinders its adoption as an industry standard. In order to alleviate
the computational issues, we present a diff-based probabilistic approach to mutation
analysis that drastically reduces the number of mutants by omitting lines of code
without statement coverage and lines that are determined to be uninteresting - we
dub these arid lines. Furthermore, by reducing the number of mutants and carefully
selecting only the most interesting ones we make it easier for humans to understand
and evaluate the result of mutation analysis. We propose a heuristic for judging whether
a node is arid or not, conditioned on the programming language. We focus on a code-review
based approach and consider the effects of surfacing mutation results on developer
attention. The described system is used by 6,000 engineers in Google on all code changes
they author or review, affecting in total more than 13,000 code authors as part of
the mandatory code review process. The system processes about 30% of all diffs across
Google that have statement coverage calculated. About 15% of coverage statement calculations
fail across Google.},
booktitle = {Proceedings of the 40th International Conference on Software Engineering: Software Engineering in Practice},
pages = {163–171},
numpages = {9},
location = {Gothenburg, Sweden},
series = {ICSE-SEIP '18}
}






@incollection{MutationSurvey,
  title={Mutation testing advances: an analysis and survey},
  author={Papadakis, Mike and Kintis, Marinos and Zhang, Jie and Jia, Yue and Le Traon, Yves and Harman, Mark},
  booktitle={Advances in Computers},
  volume={112},
  pages={275--378},
  year={2019},
  publisher={Elsevier}
}


@misc{dataset-small,
  title={Directory of ERC20 tokens},
  author={Trust Wallet},
  howpublished = "\url{https://github.com/TrustWallet/tokens}",
  year={2018}
}

@inproceedings{contractfuzzer,
  title={Contractfuzzer: Fuzzing smart contracts for vulnerability detection},
  author={Jiang, Bo and Liu, Ye and Chan, WK},
  booktitle={Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering},
  pages={259--269},
  year={2018}
}

@misc{solfuzz,
  howpublished="\url{https://github.com/b-mueller/solfuzz}",
  author = "Bernhard Mueller"
  }

@inproceedings{Pacheco,
  author = "Carlos Pacheco and Shuvendu K. Lahiri and Michael D. Ernst and Thomas Ball",
  title = "Feedback-directed Random Test Generation",
  booktitle = "International Conference on Software Engineering",
  year = "2007",
  pages = "75--84"
}

@misc{albert2019gasol,
    title={GASOL: Gas Analysis and Optimization for Ethereum Smart Contracts},
    author={Elvira Albert and Jesús Correas and Pablo Gordillo and Guillermo Román-Díez and Albert Rubio},
    year={2019},
    eprint={1912.11929},
    archivePrefix={arXiv},
    primaryClass={cs.PL}
}

@INPROCEEDINGS{eclipser,
  author = {Jaeseung Choi and Joonun Jang and Choongwoo Han and Sang Kil Cha},
  title = {Grey-box Concolic Testing on Binary Code},
  booktitle = {Proceedings of the International Conference on Software Engineering},
  pages = {736--747},
  year = 2019
}

@book{ewd,
editor = {Dahl, O. J. and Dijkstra, E. W. and Hoare, C. A. R.},
title = {Structured Programming},
year = {1972},
isbn = {0122005503},
publisher = {Academic Press Ltd.},
address = {GBR},
abstract = {In recent years there has been an increasing interest in the art of computer programming,
the conceptual tools available for the design of programs, and the prevention of programming
oversights and error. The initial outstanding contribution to our understanding of
this subject was made by E. W. Dijkstra, whose Notes on Structured Programming form
the first and major section of this book. They clearly expound the reflections of
a brilliant programmer on the methods which he has hitherto unconsciously applied;
there can be no programmer of the present day who could not increase his skills by
a study and conscious application of these principles.In the second monograph I have
tried to describe how similar principles can be applied in the design of data structures.
I have suggested that in analysing a problem and groping towards a solution, a programmer
should take advantage of abstract concepts such as sets, sequences, and mappings;
and judiciously postpone decisions on representation until he is constructing the
more detailed code of the program. The monograph also describes a range of useful
ideas for data representation, and suggests the criteria relevant for their selection.The
third monograph provides a synthesis of the previous two, and expounds the close theoretical
and practical connections between the design of data and the design of programs. It
introduces useful additional methods for program and data structuring which may be
unfamiliar to many programmers. The examples show that structured programming principles
can be equally applied in "bottom-up" as in "top-down" program design. The original
inspiration, insight, and all the examples were contributed by O.-J. Dahl; I have
only assembled the material, and added some additional explanations where I found
it difficult to understand.}
}

@inproceedings{covdev,
author = {Gopinath, Rahul and Jensen, Carlos and Groce, Alex},
title = {Code Coverage for Suite Evaluation by Developers},
year = {2014},
isbn = {9781450327565},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2568225.2568278},
doi = {10.1145/2568225.2568278},
abstract = { One of the key challenges of developers testing code is determining a test suite's
quality -- its ability to find faults. The most common approach is to use code coverage
as a measure for test suite quality, and diminishing returns in coverage or high absolute
coverage as a stopping rule. In testing research, suite quality is often evaluated
by a suite's ability to kill mutants (artificially seeded potential faults). Determining
which criteria best predict mutation kills is critical to practical estimation of
test suite quality. Previous work has only used small sets of programs, and usually
compares multiple suites for a single program. Practitioners, however, seldom compare
suites --- they evaluate one suite. Using suites (both manual and automatically generated)
from a large set of real-world open-source projects shows that evaluation results
differ from those for suite-comparison: statement (not block, branch, or path) coverage
predicts mutation kills best. },
booktitle = {Proceedings of the 36th International Conference on Software Engineering},
pages = {72–82},
numpages = {11},
keywords = {test frameworks, evaluation of coverage criteria, statistical analysis},
location = {Hyderabad, India},
series = {ICSE 2014}
}



@inproceedings{10.1145/1294211.1294256,
author = {Olsen, Dan R.},
title = {Evaluating User Interface Systems Research},
year = {2007},
isbn = {9781595936790},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1294211.1294256},
doi = {10.1145/1294211.1294256},
abstract = {The development of user interface systems has languished with the stability of desktop
computing. Future systems, however, that are off-the-desktop, nomadic or physical
in nature will involve new devices and new software systems for creating interactive
applications. Simple usability testing is not adequate for evaluating complex systems.
The problems with evaluating systems work are explored and a set of criteria for evaluating
new UI systems work is presented.},
booktitle = {Proceedings of the 20th Annual ACM Symposium on User Interface Software and Technology},
pages = {251–258},
numpages = {8},
keywords = {user interface systems evaluation},
location = {Newport, Rhode Island, USA},
series = {UIST '07}
}



@misc{ma2019gasfuzz,
    title={GasFuzz: Generating High Gas Consumption Inputs to Avoid Out-of-Gas Vulnerability},
    author={Fuchen Ma and Ying Fu and Meng Ren and Wanting Sun and Zhe Liu and Yu Jiang and Jun Sun and Jiaguang Sun},
    year={2019},
    eprint={1910.02945},
    archivePrefix={arXiv},
    primaryClass={cs.CR}
}

@inproceedings{lemieux2018perffuzz,
  title={Perffuzz: Automatically generating pathological inputs},
  author={Lemieux, Caroline and Padhye, Rohan and Sen, Koushik and Song, Dawn},
  booktitle={Proceedings of the 27th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  pages={254--265},
  year={2018}
}

@article{swarmIEEE,
  author = "Gerard Holzmann and Rajeev Joshi and Alex Groce",
  title = "Swarm Verification Techniques",
  journal = "IEEE Transactions on Software Engineering",
volume = {37},
number = {6},
  year = 2011,
  pages = "845--857"
}


@inproceedings{groce2013help,
  title={Help, help, {I'm} being suppressed! The significance of suppressors in software testing},
  author={Groce, Alex and Zhang, Chaoqiang and Alipour, Mohammad Amin and Eide, Eric and Chen, Yang and Regehr, John},
  booktitle={2013 IEEE 24th International Symposium on Software Reliability Engineering (ISSRE)},
  pages={390--399},
  year={2013},
  organization={IEEE}
}

@inproceedings{csmith,
  title={Finding and understanding bugs in C compilers},
  author={Yang, Xuejun and Chen, Yang and Eide, Eric and Regehr, John},
  booktitle={Proceedings of the 32nd ACM SIGPLAN conference on Programming language design and implementation},
  pages={283--294},
  year={2011}
}

@inproceedings{ASE08,
  author = "James H. Andrews and Alex Groce and Melissa Weston and Ru-Gang Xu",
  title = "Random Test Run Length and Effectiveness",
  booktitle = "Automated Software Engineering",
pages = "19--28",
  year = 2008
}

@inproceedings{swarm-paper,
  author = "Alex Groce and Chaoqiang Zhang and Eric Eide and Yang Chen and John Regehr",
  title = "Swarm Testing",
  booktitle = "International Symposium on Software Testing and Analysis",
  year = 2012,
  pages = "78--88"
}


@book{SPIN,
  author="Gerard J. Holzmann",
  title="The {SPIN} Model Checker: Primer and Reference Manual",
  publisher="Addison-Wesley Professional",
  year="2003"}

@misc{chainfuzz,
  howpublished="\url{https://github.com/ChainSecurity/ChainFuzz}",
  author="{Chain Security}"
  }

@inproceedings{oyente,
 author = {Luu, Loi and Chu, Duc-Hiep and Olickel, Hrishi and Saxena, Prateek and Hobor, Aquinas},
 title = {Making Smart Contracts Smarter},
 series = {CCS '16},
 year = {2016},
} 
@inproceedings{AFLplusplus-Woot20,
	author = {Andrea Fioraldi and Dominik Maier and Heiko Ei{\ss}feldt and Marc Heuse},
	title = {AFL++ : Combining Incremental Steps of Fuzzing Research},
	booktitle = {14th {USENIX} Workshop on Offensive Technologies ({WOOT} 20)},
	year = {2020},
	url = {https://www.usenix.org/conference/woot20/presentation/fioraldi},
	publisher = {{USENIX} Association},
	month = aug,
}

@inproceedings{QASan-SecDev20,
  author={Fioraldi, Andrea and D’Elia, Daniele Cono and Querzoni, Leonardo},
  booktitle={2020 IEEE Secure Development Conference (SecDev)}, 
  title={Fuzzing Binaries for Memory Safety Errors with {QASan}}, 
  year={2020}
}

@inproceedings{BaseSAFE-WiSec20,
  author = {Maier, Dominik and Seidel, Lukas and Park, Shinjo},
  title = {BaseSAFE: Baseband Sanitized Fuzzing through Emulation},
  year = {2020},
  isbn = {9781450380065},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3395351.3399360},
  doi = {10.1145/3395351.3399360},
  booktitle = {Proceedings of the 13th ACM Conference on Security and Privacy in Wireless and Mobile Networks},
  pages = {122--132},
  numpages = {11},
  keywords = {rehosting, cellular, fuzzing, security},
  location = {Linz, Austria},
  series = {WiSec '20}
}

@inproceedings{FuzzingSymbolicExpressions-ICSE21,
  author={Borzacchiello, Luca and Coppa, Emilio and Demetrescu, Camil},
  booktitle={2021 IEEE/ACM 43rd International Conference on Software Engineering (ICSE)},
  title={Fuzzing Symbolic Expressions},
  year={2021},
  volume={},
  number={},
  pages={711-722},
  doi={10.1109/ICSE43902.2021.00071}
}

@inproceedings{PMFuzz-ASPLOS21,
  title={PMFuzz: Test Case Generation for Persistent Memory Programs},
  author={Liu, Sihang and Mahar, Suyash and Ray, Baishakhi and Khan, Samira},
  booktitle={Proceedings of the Twenty-sixth International Conference on Architectural Support for Programming Languages and Operating Systems},
  year={2021}
}

@inproceedings {InvsCov-USENIX21,
  author = {Andrea Fioraldi and Daniele Cono D'Elia and Davide Balzarotti},
  title = {The Use of Likely Invariants as Feedback for Fuzzers},
  booktitle = {30th {USENIX} Security Symposium ({USENIX} Security 21)},
  year = {2021},
  url = {https://www.usenix.org/conference/usenixsecurity21/presentation/fioraldi},
  publisher = {{USENIX} Association},
  month = aug,
}

@inproceedings{Gramatron-ISSTA21,
  author = {Srivastava, Prashast and Payer, Mathias},
  title = {Gramatron: Effective Grammar-Aware Fuzzing},
  year = {2021},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {http://nebelwelt.net/files/21ISSTA.pdf},
  doi = {10.1145/3460319.3464814},
  booktitle = {Proceedings of the 30th ACM SIGSOFT International Symposium on Software Testing and Analysis},
  keywords = {Fuzzing, grammar-aware, dynamic software analysis},
  location = {Virtual, Denmark},
  series = {ISSTA 2021}
}

@inproceedings{goodman2018deepstate,
  title={{DeepState}: Symbolic unit testing for {C} and {C++}},
  author={Goodman, Peter and Groce, Alex},
  booktitle={NDSS Workshop on Binary Analysis Research},
  year={2018}
}

@inproceedings{jiang:ase:2018,
  author = {Jiang, Bo and Liu, Ye and Chan, W. K.},
  title = {{ContractFuzzer}: Fuzzing Smart Contracts for Vulnerability Detection},
  year = {2018},
  booktitle={International Conference on Automated Software Engineering},
  pages = {259--269}
}

@inproceedings{harvey,
  title = {Harvey: A Greybox Fuzzer for Smart Contracts},
  author = {W{\"u}stholz, Valentin and Christakis, Maria},
  booktitle = {Foundations of
    Software Engineering},
  pages = {1398--1409},
  year = 2020
}

@inproceedings{sfuzz,
author = {Nguyen, Tai D. and Pham, Long H. and Sun, Jun and Lin, Yun and Minh, Quang Tran},
title = {{SFuzz}: An Efficient Adaptive Fuzzer for {Solidity} Smart Contracts},
year = {2020},

booktitle = {International Conference on Software Engineering},
pages = {778–788}
}

@inproceedings{he2019learning,
  title={Learning to fuzz from symbolic execution with application to smart contracts},
  author={He, Jingxuan and Balunovi{\'c}, Mislav and Ambroladze, Nodar and Tsankov, Petar and Vechev, Martin},
  booktitle={ Conference on Computer and Communications Security},
  pages={531--548},
  year={2019}
}

@article{dietterich2002ensemble,
  title={Ensemble learning},
  author={Dietterich, Thomas G and others},
  journal={The handbook of brain theory and neural networks},
  volume={2},
  pages={110--125},
  year={2002},
  publisher={MIT press Cambridge, Massachusetts}
}

@inproceedings{zhou2021foundationdb,
  title={{FoundationDB:} A Distributed Unbundled Transactional Key Value Store},
  author={Zhou, Jingyu and Xu, Meng and Shraer, Alexander and Namasivayam, Bala and Miller, Alex and Tschannen, Evan and Atherton, Steve and Beamon, Andrew J and Sears, Rusty and Leach, John and others},
  year={2021},
  booktitle={{ACM} {SIGMOD}}
}

@article{le2014compiler,
  title={Compiler validation via equivalence modulo inputs},
  author={Le, Vu and Afshari, Mehrdad and Su, Zhendong},
  journal={ACM SIGPLAN Notices},
  volume={49},
  number={6},
  pages={216--226},
  year={2014},
  publisher={ACM New York, NY, USA}
}


@inproceedings{chen2019enfuzz,
  title={Enfuzz: Ensemble fuzzing with seed synchronization among diverse fuzzers},
  author={Chen, Yuanliang and Jiang, Yu and Ma, Fuchen and Liang, Jie and Wang, Mingzhe and Zhou, Chijin and Jiao, Xun and Su, Zhuo},
  booktitle={{USENIX} Security Symposium},
  pages={1967--1983},
  year={2019}
}

@inproceedings{dewey2015fuzzing,
  title={Fuzzing the Rust typechecker using CLP (T)},
  author={Dewey, Kyle and Roesch, Jared and Hardekopf, Ben},
  booktitle={2015 30th IEEE/ACM International Conference on Automated Software Engineering (ASE)},
  pages={482--493},
  year={2015},
  organization={IEEE}
}



@misc{solidityj-code,
  title={Solidity grammar for ANTLR4 },
  author={Federico Bond},
  howpublished = "\url{https://github.com/solidityj/solidity-antlr4}",
  year={2017}
}

@inproceedings{10.1145/2491956.2462173,
author = {Chen, Yang and Groce, Alex and Zhang, Chaoqiang and Wong, Weng-Keen and Fern, Xiaoli and Eide, Eric and Regehr, John},
title = {Taming Compiler Fuzzers},
year = {2013},
isbn = {9781450320146},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2491956.2462173},
doi = {10.1145/2491956.2462173},
abstract = {Aggressive random testing tools ("fuzzers") are impressively effective at finding compiler bugs. For example, a single test-case generator has resulted in more than 1,700 bugs reported for a single JavaScript engine. However, fuzzers can be frustrating to use: they indiscriminately and repeatedly find bugs that may not be severe enough to fix right away. Currently, users filter out undesirable test cases using ad hoc methods such as disallowing problematic features in tests and grepping test results. This paper formulates and addresses the fuzzer taming problem: given a potentially large number of random test cases that trigger failures, order them such that diverse, interesting test cases are highly ranked. Our evaluation shows our ability to solve the fuzzer taming problem for 3,799 test cases triggering 46 bugs in a C compiler and 2,603 test cases triggering 28 bugs in a JavaScript engine.},
booktitle = {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {197–208},
numpages = {12},
keywords = {automated testing, compiler testing, random testing, compiler defect, test-case reduction, bug reporting, fuzz testing},
location = {Seattle, Washington, USA},
series = {PLDI '13}
}


@inproceedings{Taming,
author = {Chen, Yang and Groce, Alex and Zhang, Chaoqiang and Wong, Weng-Keen and Fern, Xiaoli and Eide, Eric and Regehr, John},
title = {Taming Compiler Fuzzers},
year = {2013},
url = {https://doi.org/10.1145/2499370.2462173},
doi = {10.1145/2499370.2462173},
abstract = {Aggressive random testing tools ("fuzzers") are impressively effective at finding compiler bugs. For example, a single test-case generator has resulted in more than 1,700 bugs reported for a single JavaScript engine. However, fuzzers can be frustrating to use: they indiscriminately and repeatedly find bugs that may not be severe enough to fix right away. Currently, users filter out undesirable test cases using ad hoc methods such as disallowing problematic features in tests and grepping test results. This paper formulates and addresses the fuzzer taming problem: given a potentially large number of random test cases that trigger failures, order them such that diverse, interesting test cases are highly ranked. Our evaluation shows our ability to solve the fuzzer taming problem for 3,799 test cases triggering 46 bugs in a C compiler and 2,603 test cases triggering 28 bugs in a JavaScript engine.},
booktitle={ACM SIGPLAN Symposium on Programming Language Design and Implementation},
month = jun,
pages = {197–208},
numpages = {12},
keywords = {fuzz testing, compiler testing, compiler defect, test-case reduction, random testing, bug reporting, automated testing}
}

@article{coupon,
  title={Asymptotic distributions for the coupon collector's problem},
  author={Baum, Leonard E and Billingsley, Patrick},
  journal={The Annals of Mathematical Statistics},
  volume={36},
  number={6},
  pages={1835--1839},
  year={1965},
  publisher={JSTOR}
}

@article{Gonzalez85,
  author = "Teofilo F. Gonzalez",
  title = "Clustering to Minimize the Maximum Intercluster Distance",
  journal = "Theoretical Computer Science",
  volume = 38,
  year = 1985,
  pages = "293--306",
}


@misc{webassembly,
  title={WebAssembly},
  howpublished = "\url{http://webassembly.org/}",
  year={2016}
}

@inproceedings{securify,
 author = {Tsankov, Petar and Dan, Andrei and Drachsler-Cohen, Dana and Gervais, Arthur and B\"{u}nzli, Florian and Vechev, Martin},
 title = {Securify: Practical Security Analysis of Smart Contracts},
 series = {CCS '18},
 year = {2018},
}

@inproceedings{Discontents,
author = {Groce, Alex and Alipour, Mohammad Amin and Gopinath, Rahul},
title = {Coverage and Its Discontents},
year = {2014},
isbn = {9781450332101},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2661136.2661157},
doi = {10.1145/2661136.2661157},
abstract = {Everyone wants to know one thing about a test suite: will it detect enough bugs? Unfortunately, in most settings that matter, answering this question directly is impractical or impossible. Software engineers and researchers therefore tend to rely on various measures of code coverage (where mutation testing is considered a form of syntactic coverage). A long line of academic research efforts have attempted to determine whether relying on coverage as a substitute for fault detection is a reasonable solution to the problems of test suite evaluation. This essay argues that the profusion of coverage-related literature is in part a sign of an underlying uncertainty as to what exactly it is that measuring coverage should achieve, as well as how we would know if it can, in fact, achieve it. We propose some solutions and mitigations, but the primary focus of this essay is to clarify the state of current confusions regarding this key problem for effective software testing.},
booktitle = {Proceedings of the 2014 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming \& Software},
pages = {255–268},
numpages = {14},
keywords = {evaluation, testing, coverage},
location = {Portland, Oregon, USA},
series = {Onward\! 2014}
}



@inproceedings{FormalCoupon,
author = {Arcuri, Andrea and Iqbal, Muhammad Zohaib and Briand, Lionel},
title = {Formal Analysis of the Effectiveness and Predictability of Random Testing},
year = {2010},
isbn = {9781605588230},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1831708.1831736},
doi = {10.1145/1831708.1831736},
abstract = {There has been a lot of work to shed light on whether random testing is actually a useful testing technique. Despite its simplicity, several successful real-world applications appear in the literature. Although it is not going to solve all possible testing problems, random testing is an essential tool in the hands of software testers. In this paper, we address general questions about random testing, such as how long random testing needs on average to achieve testing targets (e.g., coverage), how does it scale and how likely is it to yield similar results if we re-run random testing on the same testing problem. Due to its simplicity that makes the mathematical analysis of random testing tractable, we provide precise and rigorous answers to these questions. Our formal results can be applied to most types of software and testing criteria. Simulations are carried out to provide further support to our formal results. The obtained results are then used to assess the validity of empirical analyses reported in the literature. Results show that random testing is more effective and predictable than previously thought.},
booktitle = {Proceedings of the 19th International Symposium on Software Testing and Analysis},
pages = {219–230},
numpages = {12},
keywords = {random testing, predictability, coupon collector, theory, schur function},
location = {Trento, Italy},
series = {ISSTA '10}
}



@article{ArcuriLen,
  author    = {Andrea Arcuri},
  title     = {A Theoretical and Empirical Analysis of the Role of Test Sequence
               Length in Software Testing for Structural Coverage},
  journal   = {{IEEE} Trans. Software Eng.},
  volume    = {38},
  number    = {3},
  pages     = {497--519},
  year      = {2012},
  url       = {https://doi.org/10.1109/TSE.2011.44},
  doi       = {10.1109/TSE.2011.44},
  timestamp = {Wed, 17 May 2017 10:56:38 +0200},
  biburl    = {https://dblp.org/rec/journals/tse/Arcuri12.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@INPROCEEDINGS{ICSEDiff,
  author={Groce, Alex and Holzmann, Gerard and Joshi, Rajeev},
  booktitle={29th International Conference on Software Engineering (ICSE'07)}, 
  title={Randomized Differential Testing as a Prelude to Formal Verification}, 
  year={2007},
  volume={},
  number={},
  pages={621-631},
  doi={10.1109/ICSE.2007.68}}

@article{arcuri2014hitchhiker,
title={A hitchhiker's guide to statistical tests for assessing randomized algorithms in software engineering},
author={Arcuri, Andrea and Briand, Lionel},
journal={Software Testing, Verification and Reliability},
volume={24},
number={3},
pages={219--250},
year={2014}
}

@misc{Hypothesis,
author = "David R. MacIver",
title = "Hypothesis: Test faster, fix more",
howpublished = "\url{http://hypothesis.works/}",
year = 2013,
month = "March"
}

@misc{grishchenko2018semantic,
  author = {Ilya Grishchenko and Matteo Maffei and Clara Schneidewind},
  Title = {A Semantic Framework for the Security Analysis of Ethereum smart contracts},
  Year = {2018},
  howpublished = {arXiv:1802.08660},
  note = {Accessed:2018-03-12},
  url = {https://arxiv.org/pdf/1802.08660.pdf},
}

@inproceedings{smartcheck,
 author = {Tikhomirov S. and et al.},
 title = {SmartCheck: Static Analysis of Ethereum Smart Contracts},
 series = {WETSEB},
 year = {2018},
}

@misc{atzei2016survey,
  author = {Nicola Atzei and Massimo Bartoletti and Tiziana Cimoli},
  title = {A survey of attacks on Ethereum smart contracts},
  publisher = {Cryptology ePrint Archive, Report 2016/1007},
  year = {2016},
  month = {Oct},
  note = {Accessed: 2016-11-08},
  url = {https://eprint.iacr.org/2016/1007.pdf},
}

@inproceedings{DBLP:conf/ndss/KalraGDS18,
  author    = {Sukrit Kalra and
               Seep Goel and
               Mohan Dhawan and
               Subodh Sharma},
  title     = {{ZEUS:} Analyzing Safety of Smart Contracts},
  booktitle = {25th Annual Network and Distributed System Security Symposium, {NDSS}
               2018, San Diego, California, USA, February 18-21, 2018},
  year      = {2018},
  crossref  = {DBLP:conf/ndss/2018},
  url       = {http://wp.internetsociety.org/ndss/wp-content/uploads/sites/25/2018/02/ndss2018\_09-1\_Kalra\_paper.pdf},
  timestamp = {Thu, 09 Aug 2018 10:57:16 +0200},
  biburl    = {https://dblp.org/rec/bib/conf/ndss/KalraGDS18},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@book{mao,
  title={The Hundred Flowers Campaign and the Chinese Intellectuals},
  author={MacFarquhar, Roderick},
  year={1966},
  publisher={Praeger},
  city={New York}
  }

@book{cervantes,
  title={Don Quixote},
  author={Cervantes, Miguel de},
  year={1605}
}



@book{chesterton,
  title={The Uses of Diversity: A Book of Essays},
  author={Chesterton, G. K.},
  year = 1920
  }

@book{Montaigne,
 title={Essays},
 author={Montaigne, Michel de},
 year={1595}
 }

@article{Brooks1987NoSB,
  title={No Silver Bullet Essence and Accidents of Software Engineering},
  author={Brooks, Frederic P.},
  journal={Computer},
  year={1987},
  volume={20},
  pages={10-19}
}

@article{Brent2018VandalAS,
  title={Vandal: A Scalable Security Analysis Framework for Smart Contracts},
  author={Lexi Brent and et al.},
  journal={CoRR},
  year={2018},
  volume={abs/1809.03981}
}

@inproceedings{Spirit,
author = "Glenn Reeves and Tracy Neilson",
title = "The {Mars} {Rover} {Spirit} {Flash} Anomaly",
booktitle = "IEEE Aerospace Conference",
year = "2005"
}


@inproceedings {teether,
  author = {Johannes Krupp and Christian Rossow},
  title = {teEther: Gnawing at Ethereum to Automatically Exploit Smart Contracts},
  booktitle = {USENIX Security )},
  year = {2018},
}

@article{tstlsttt,
author = "Josie Holmes and Alex Groce and Jervis Pinto and Pranjal Mittal and Pooria Azimi and Kevi
n Kellar and James O'Brien",
title = "{TSTL:} the Template Scripting Testing Language",
journal = "International Journal on Software Tools for Technology Transfer",
year = 2018,
volume=20,
number =1,
pages="57--78"
}


@inproceedings{WODACommon,
author = {Groce, Alex and Erwig, Martin},
title = {Finding Common Ground: Choose, Assert, and Assume},
booktitle = {International Workshop on Dynamic Analysis},
year = {2012},
pages = {12--17}
} 


@misc{ethertrust,
  title={EtherTrust: Sound Static Analysis of Ethereum bytecode},
  author={Ilya Grishchenko and Matteo Maffei and Clara Schneidewind},
  year={2018}
}

@inproceedings{maian,
  author = {Nikolic, Ivica and Kolluri, Aashish and Sergey, Ilya and Saxena, Prateek and Hobor, Aquinas},
  booktitle = {ACSAC},
  title = {Finding The Greedy, Prodigal, and Suicidal Contracts at Scale},
  year = {2018}
}

@inproceedings{FC20,
  title={What are the Actual Flaws in Important Smart Contracts (and How Can We Find Them)?},
  author={Alex Groce and Josselin Feist and Gustavo Grieco and Michael Colburn},
  year={2020},
  booktitle="International Conference on Financial Cryptography and Data Security",
  pages={634--653}
}

@article{groce2018verified,
  title={How verified (or tested) is my code? falsification-driven verification and testing},
  author={Groce, Alex and Ahmed, Iftekhar and Jensen, Carlos and McKenney, Paul E and  Holmes, Josie},
  journal={Automated Software Engineering Journal},
  year={2018},
 volume = 25,
 number = 4,
 pages = "917--960"
}

@article{demillo1978hints,
  title={Hints on test data selection: Help for the practicing programmer},
  author="Richard J. Lipton and Richard A DeMillo and Frederick G Sayward",
  journal={Computer},
  volume={11},
  number={4},
  pages={34--41},
  year={1978},
  publisher={IEEE}
}


@book{budd1979mutation,
  title={Mutation analysis},
  author="Timothy Budd and Richard J. Lipton and Richard A DeMillo and Frederick G Sayward",
  year={1979},
  publisher={Yale University, Department of Computer Science}
}


@inproceedings{mutKernel,
  author = "Iftekhar Ahmed and Carlos Jensen and Alex Groce and Paul E. McKenney",
  title = "Applying Mutation Analysis on Kernel Test Suites: an Experience Report",
  year = 2017,
  month = "March",
  pages = "110--115",
  booktitle = "International Workshop on Mutation Analysis"
  }



@inproceedings{SSA,
  author = {Rosen, Barry K. and Wegman, Mark N. and Zadeck, F. Kenneth},
  booktitle = {POPL},
  title = {Global Value Numbers and Redundant Computations},
  year = {1988}
}


@misc{scilla,
  title={SCILLA Safe-By-Design Smart Contract Language},
  author={Zilliqa},
  howpublished = "\url{https://scilla-lang.org/}",
  year={Accessed on Jan 10, 2019}
}

@misc{michelson,
  title={Michelson: the language of Smart Contracts in Tezos},
  author={Tezos},
  howpublished = "\url{http://www.liquidity-lang.org/doc/reference/michelson.html}",
  year={Accessed on Jan 10, 2019}
}

@inbook{CompBug,
  author = "Scott Bauer and Pascal Cuoq and John Regehr",
  title = "POC||GTFO",
  chapter = "Compiler Bug Backdoors",
  publisher = "No Starch Press",
  year = 2017
  }

@inproceedings{combypaper,
author = {van Tonder, Rijnard and Le Goues, Claire},
title = {Lightweight Multi-Language Syntax Transformation with Parser Parser Combinators},
year = {2019},
isbn = {9781450367127},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3314221.3314589},
doi = {10.1145/3314221.3314589},
abstract = {Automatically transforming programs is hard, yet critical for automated program refactoring,
rewriting, and repair. Multi-language syntax transformation is especially hard due
to heterogeneous representations in syntax, parse trees, and abstract syntax trees
(ASTs). Our insight is that the problem can be decomposed such that (1) a common grammar
expresses the central context-free language (CFL) properties shared by many contemporary
languages and (2) open extension points in the grammar allow customizing syntax (e.g.,
for balanced delimiters) and hooks in smaller parsers to handle language-specific
syntax (e.g., for comments). Our key contribution operationalizes this decomposition
using a Parser Parser combinator (PPC), a mechanism that generates parsers for matching
syntactic fragments in source code by parsing declarative user-supplied templates.
This allows our approach to detach from translating input programs to any particular
abstract syntax tree representation, and lifts syntax rewriting to a modularly-defined
parsing problem. A notable effect is that we skirt the complexity and burden of defining
additional translation layers between concrete user input templates and an underlying
abstract syntax representation. We demonstrate that these ideas admit efficient and
declarative rewrite templates across 12 languages, and validate effectiveness of our
approach by producing correct and desirable lightweight transformations on popular
real-world projects (over 50 syntactic changes produced by our approach have been
merged into 40+). Our declarative rewrite patterns require an order of magnitude less
code compared to analog implementations in existing, language-specific tools.},
booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {363–378},
numpages = {16},
keywords = {rewriting, syntax, parsers, transformation},
location = {Phoenix, AZ, USA},
series = {PLDI 2019}
}

@INPROCEEDINGS{Angora,
  author={Chen, Peng and Chen, Hao},
  booktitle={2018 IEEE Symposium on Security and Privacy (SP)}, 
  title={Angora: Efficient Fuzzing by Principled Search}, 
  year={2018},
  volume={},
  number={},
  pages={711-725},
  doi={10.1109/SP.2018.00046}}

@inproceedings{semantic-crash-bucketing,
 author = {van Tonder, Rijnard and Kotheimer, John and Le Goues, Claire},
 title = {Semantic Crash Bucketing},
 booktitle = {Proceedings of the 33rd ACM/IEEE International Conference on Automated Software Engineering},
 series = {ASE 2018},
 year = {2018},
 isbn = {978-1-4503-5937-5},
 location = {Montpellier, France},
 pages = {612--622},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/3238147.3238200},
 doi = {10.1145/3238147.3238200},
 acmid = {3238200},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Automated Bug Fixing, Bug Triage, Crash Bucketing, Fuzzing, Program Transformation},
} 


@inproceedings{LangFuzz,
author = {Holler, Christian and Herzig, Kim and Zeller, Andreas},
title = {Fuzzing with Code Fragments},
year = {2012},
publisher = {USENIX Association},
address = {USA},
abstract = {Fuzz testing is an automated technique providing random data as input to a software
system in the hope to expose a vulnerability. In order to be effective, the fuzzed
input must be common enough to pass elementary consistency checks; a JavaScript interpreter,
for instance, would only accept a semantically valid program. On the other hand, the
fuzzed input must be uncommon enough to trigger exceptional behavior, such as a crash
of the interpreter. The LangFuzz approach resolves this conflict by using a grammar
to randomly generate valid programs; the code fragments, however, partially stem from
programs known to have caused invalid behavior before. LangFuzz is an effective tool
for security testing: Applied on the Mozilla JavaScript interpreter, it discovered
a total of 105 new severe vulnerabilities within three months of operation (and thus
became one of the top security bug bounty collectors within this period); applied
on the PHP interpreter, it discovered 18 new defects causing crashes.},
booktitle = {Proceedings of the 21st USENIX Conference on Security Symposium},
pages = {38},
numpages = {1},
location = {Bellevue, WA},
series = {Security'12}
}



@article{Differential,
author = "William McKeeman",
title = "Differential testing for software",
journal = "Digital Technical Journal of Digital Equipment Corporation",
volume = "10(1)",
pages = "100--107",
year = 1998
}

@article{barr2014oracle,
  title={The oracle problem in software testing: A survey},
  author={Barr, Earl T and Harman, Mark and McMinn, Phil and Shahbaz, Muzammil and Yoo, Shin},
  journal={IEEE transactions on software engineering},
  volume={41},
  number={5},
  pages={507--525},
  year={2014},
  publisher={IEEE}
}

@article{holzmann2006power,
  title={The power of 10: Rules for developing safety-critical code},
  author={Holzmann, Gerard J},
  journal={Computer},
  volume={39},
  number={6},
  pages={95--99},
  year={2006},
  publisher={IEEE}
}

@techreport{iele,
    author = "Kasampalis, Theodoros and et al.",
    year = "2018",
    number = "http://hdl.handle.net/2142/100320",
    title = "IELE: An Intermediate-Level Blockchain Language Designed and Implemented Using Formal Semantics"
}

@misc{yul,
  title={Yul},
  author={Solidity},
  howpublished = "\url{https://solidity.readthedocs.io/en/v0.5.0/yul.html}",
  year={Accessed on Jan 10, 2019}
}

@inproceedings{BMC,
  author = "Armin Biere and Alessandro Cimatti and Edmund M. Clarke and Yunshan Zhu",
  title = "Symbolic Model Checking without {BDDs}",
  booktitle = "Tools and Algorithms for the Construction and Analysis of Systems", 
  year = "1999",
  pages = "193--207"
}

@ARTICLE{McMinn04search-basedsoftware,
author = {Phil McMinn},
title = {Search-based Software Test Data Generation: A Survey},
journal = {Software Testing, Verification and Reliability},
year = {2004},
volume = {14},
pages = {105--156}
}

@inproceedings{CBMCp,
  author = "Daniel Kroening and Edmund M. Clarke and Flavio Lerda",
  title = "A Tool for Checking {ANSI-C} Programs",
  booktitle = "Tools and Algorithms for the Construction and Analysis of Systems",
  year = "2004",
  pages = "168--176"
}

@misc{CBMC,
  howpublished = "\url{https://www.cprover.org/cbmc/}"
}
